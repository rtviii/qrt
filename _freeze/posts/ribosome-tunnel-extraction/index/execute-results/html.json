{
  "hash": "9358eab2c8be97adcce9a5db3419998f",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Ribosome Exit Tunnel Geometry\"\nsubtitle: \"Extraction Protocol via Space Partioning and DBSCAN\"\n\nengine: \"jupyter\"\nauthor:\n  - name: \"Artem Kushner\" \n    email: \"rtkushner@gmail.com\"\n    affiliations:\n      - name: KDD Group\n        url: \"https://rtviii.xyz/\"\n\n  - name: \"Khanh Dao Duc\" \n    email: \"kdd@math.ubc.ca\"\n    affiliations:\n      - name: Department of Mathematics, UBC\n        url: \"https://www.math.ubc.ca/\"\n      - name: Department of Computer Science, UBC\n        url: \"https://www.cs.ubc.ca/\"\n      - name: Department of Zoology, UBC\n        url: \"https://zoology.ubc.ca/\"\n\ndate: \"29 June 2024\"\ncategories: [biology, mesh, computer graphics]    \n\n# format:\n#   pdf:\n#     include-in-header:\n#       text: |\n#         \\usepackage{amsmath}\n\n\nexecute:\n  echo: false\n  freeze: auto\n  pip: [\"pyvista\", \"open3d\", \"scikit-learn\", \"mendeleev\", \"compas\", \"matplotlib\"]\n\n---\n\n\n\n\n\n\n\n# Introduce the ribosome a little bit and the problem\n\nThe ribosome is a complex molecular machine composed of two subunits - the large and small subunit - each made up of ribosomal RNA (rRNA) and proteins. It is central to the protein synthesis in all living organisms. The assembly of any given protein proceeds through a channel inside the ribosome known as the $Ribosome Exit Tunnel$. Here, we are interested in obtaining a fine representation of the tunnel's geometry and describe a protocol for doing so.\n\n::: {.grid}\n<style>\n.grid {\n  display: grid;\n  grid-template-columns: repeat(2, 1fr);\n  gap: 2px;\n}\n.video-container {\n  position: relative;\n  padding-bottom: 50.25%; /* 16:9 aspect ratio */\n  height: 0;\n  overflow: hidden;\n}\n.video-container video {\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n}\n</style>\n\n<div class=\"video-container\">\n  <video autoplay loop muted playsinline>\n    <source src=\"./data/1IBL.mp4\" type=\"video/mp4\">\n  </video>\n</div>\n<div class=\"video-container\">\n  <video autoplay loop muted playsinline>\n    <source src=\"./data/6R7Q.mp4\"\" type=\"video/mp4\">\n  </video>\n</div>\n<div class=\"video-container\">\n  <video autoplay loop muted playsinline>\n    <source src=\"./data/8OJ0.mp4\" type=\"video/mp4\">\n  </video>\n</div>\n<div class=\"video-container\">\n  <video autoplay loop muted playsinline>\n    <source src=\"./data/8T8C.mp4\" type=\"video/mp4\">\n  </video>\n</div>\n:::\n\n# Introduce the previous method and desirable improvements\n\n### Extraction Protocol Schematic\n\n\n![Ribosome Tunnel Extraction Workflow](./extraction_protocol.svg)\n\n### Centerline Expansion\n\n1. For each of the {$x,y,z$ coordinates, the probe radius $R_{probe}$} of the MOLE centerline, we extract the atoms that lie within $R_{probe} + R_{expansion}$ of $x,y,z$, filter out duplicates. Call this the ${\\textit{Centerline Expansion Atoms}}$.\n\n2. Calculate the coordinates of the bounding box $\\mathbf{B}$ around the point cloud formed by the $\\text{\\textit{Centerline Expansion Atoms}}$.\n\n3. (Returning to the structure), extract all atom coordinates inside the original structure that belong to $\\mathbf{B}$. Call this $\\text{\\textit{Bbox Pointcloud}}$.\n\n4. For each coordinate $C$ inside the $\\textit{Bbox Pointcloud}$:\n   - Generate indices for the voxels of a sphere with the center at $C$ and Van der Waals radius $R_{vdw} = \\mathbf{2}$.\n   (This is done by creating a voxel [sub]grid whose bounding cube is between $(C_x-R_{vdw},C_y-R_{vdw},C_z-R_{vdw})$ and $(C_x+R_{vdw},C_y+R_{vdw},C_z+R_{vdw})$, basically a cube of indices centered at $C$. Call the resulting coordinate set $\\text{\\textit{Expanded Pointcloud}}$)\n\n5. Anchor the coordinates of the ${\\textit{Expanded Pointcloud}}$ to the origin. \n   (This is done by subtracting the mean of the dataset from each coordinate and then shifting each coordinate upwards by the absolute value of the minimum of $x,y,z$). This is done to reduce the amount of empty voxel cells in the following steps.\n\n### Voxel grid\n\n\n1. Assume voxel size of $1$ in correspondence to the units of the dataset, Angstroms in our case. Alternatively, scale sphere expansion with the selected size of the grid. \n\n2. Create a boolean (zeros/ones) voxel grid with the dimensions of the ($\\textit{Expanded Pointcloud}$ + $1$), call this the $\\textit{Index Grid}$ (as opposed to the coordinate grid).\n\n3. Set voxels at index [$C_{x},C_{y},C_{z}$] for every $C$ in shifted-to-origin $\\textit{Expanded Pointcloud}$ in the $\\textit{Index Grid}$ to 1. \n\n4. Invert the $\\textit{Index Grid}$ to create a representation of the \"negative space\" inside the exit tunnel. \n\n\n### DBSCAN\n\n::: {#67b58b49 .cell execution_count=1}\n``` {.python .cell-code}\nimport pickle\nimport pyvista as pv\nfrom matplotlib import pyplot as plt\nimport numpy as np\n\n\nFONT=\"courier\"\n\neps      = 5.5\nmin_nbrs = 600\n\ndbscan_cluster_dict = pickle.load(open(\"./data/dbscan_cluster_dict.pkl\", \"rb\"))\nplotter               = pv.Plotter()\nplotter.subplot(0,0)\n#? Visualize all clusters\nfor k, v in dbscan_cluster_dict.items():\n    print(\"Cluster {} has {} points.\".format(k, len(v)))\n\nclusters_palette = dict(zip(range(-1, 60), plt.cm.terrain(np.linspace(0, 1, 60))))\nfor k, v in clusters_palette.items():\n    clusters_palette[k] = [*v[:3], 0.5]\n\ncombined_cluster_colors = []\ncombined_cluster_points = []\n\nfor dbscan_label, coordinates in dbscan_cluster_dict.items():\n    combined_cluster_points.extend(coordinates)\n    combined_cluster_colors.extend( [clusters_palette[( dbscan_label * 5 )%len(clusters_palette)]   if dbscan_label != -1 else [0, 0, 0, 0.1]] * len(coordinates) )\n\nptcloud_all_clusters         = pv.PolyData(combined_cluster_points)\nptcloud_all_clusters[\"rgba\"] = combined_cluster_colors\n\nplotter.add_mesh(ptcloud_all_clusters, scalars=\"rgba\", rgb=True, show_scalar_bar=False)\n\nplotter.add_text('DBSCAN Params:\\neps: {}\\nmin_nbrs: {}'.format(eps, min_nbrs), position='upper_right', font_size=12, shadow=True, font=FONT, color='black')\n\nplotter.add_text('DBSCAN Clusters', position='upper_left', font_size=14, shadow=True, font=FONT, color='black')\nplotter.show()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nCluster -1 has 88231 points.\nCluster 0 has 56314 points.\nCluster 1 has 1033 points.\nCluster 2 has 854 points.\nCluster 3 has 8342 points.\nCluster 4 has 785 points.\nCluster 5 has 3025 points.\nCluster 6 has 1630 points.\nCluster 7 has 1023 points.\nCluster 8 has 2319 points.\nCluster 9 has 4294 points.\nCluster 10 has 1313 points.\nCluster 11 has 873 points.\nCluster 12 has 912 points.\nCluster 13 has 2932 points.\nCluster 14 has 7568 points.\nCluster 15 has 923 points.\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n/home/rtviii/dev/riboxyz/mesh_venv/lib/python3.11/site-packages/pyvista/core/utilities/points.py:52: UserWarning:\n\nPoints is not a float type. This can cause issues when transforming or applying filters. Casting to ``np.float32``. Disable this by passing ``force_float=False``.\n\n```\n:::\n\n::: {.cell-output .cell-output-display}\n```{=html}\n<script type=\"application/vnd.jupyter.widget-view+json\">\n{\"model_id\":\"4cad17826cd545cdaa5eed6d12834257\",\"version_major\":2,\"version_minor\":0,\"quarto_mimetype\":\"application/vnd.jupyter.widget-view+json\"}\n</script>\n```\n:::\n:::\n\n\n### Normal Estimation\n\n0. Largest DBSCAN Cluster\n1. surface Points\n2. delaunay_3d \n3. surface as pointset\n4. Normal Estimation: KDTreeSearch \n5. Normal Orientation via consistent tangent plane\n\n\n\n\n### Visualize Mesh\n\n::: {#b3221628 .cell execution_count=2}\n``` {.python .cell-code}\n\"\"\"\n@translation_vectors is a np.ndarray of shape (2,3) where\n    - the first row is the means of the coordinate set\n    - the second row is the deviations of the normalized coordinate set\n    (to be used to reverse the normalization process or to travel to this coordinate frame)\n\"\"\"\nimport pyvista as pv\nimport json\nimport numpy as np\n\nFONT                  = 'courier'\nCHAIN_PT_SIZE         = 8\nPTC_PT_SIZE           = 20\nCHAIN_LANDMARK_COLORS = [\"purple\",\"orange\", \"cornflowerblue\", \"cornsilk\", \"crimson\", \"darkblue\", \"darkcyan\", \"darkgoldenrod\", \"darkgray\", \"darkgreen\", \"darkkhaki\", \"darkmagenta\", \"darkolivegreen\", \"darkorange\", \"darkorchid\", \"darkred\", \"rebeccapurple\", \"rosybrown\", \"royalblue\", \"saddlebrown\", \"salmon\", \"sandybrown\", \"seagreen\"]\n\ndef retrieve_ptc_and_chain_atoms(rcsb_id):\n        with open( \"./data/4UG0_tunnel_atoms_bbox.json\", \"r\", ) as infile:\n            bbox_atoms: list[dict] = json.load(infile)\n            _atom_centers       = np.array(list(map(lambda x: x[\"coord\"], bbox_atoms)))\n            _vdw_radii          = np.array(list(map(lambda x: x[\"vdw_radius\"], bbox_atoms)))\n\n\n        with open( \"./data/4UG0_PTC.json\", \"r\", ) as infile:\n            ptc_data = json.load(infile)\n\n        atom_coordinates_by_chain: dict[str, list] = {}\n        for atom in bbox_atoms:\n            if len(atom[\"chain_nomenclature\"]) < 1:\n                # print( \"atom \", atom, \"has no chain nomenclature\", atom[\"chain_nomenclature\"] )\n                continue\n            if atom[\"chain_nomenclature\"][0] not in atom_coordinates_by_chain:\n                atom_coordinates_by_chain[atom[\"chain_nomenclature\"][0]] = []\n            atom_coordinates_by_chain[atom[\"chain_nomenclature\"][0]].extend([atom[\"coord\"]])\n\n        ptc_midpoint = np.array(ptc_data[\"midpoint_coordinates\"])\n\n        return ptc_midpoint, atom_coordinates_by_chain\n\n# src_taxid = RibosomeOps(rcsb_id).get_taxids()[0][0]\nrcsb_id = \"4UG0\"\nsrc_taxid = 9606\ntaxname   = \"Homo sapiens\"\n\nptc_midpoint,atom_coordinates_by_chain = retrieve_ptc_and_chain_atoms(rcsb_id)\npoisson_recon = \"./data/4UG0_poisson_recon_ascii.ply\"\nmesh_   = pv.read(poisson_recon)\nplotter = pv.Plotter()\nplotter.add_mesh(mesh_, opacity=1)\n\n\nfor i, ( chain_name, coords ) in enumerate(atom_coordinates_by_chain.items()):\n    plotter.add_points(\n            np.array(coords),\n          point_size               = 8 if chain_name in [\"eL39\",\"uL4\",\"uL22\", \"uL23\"] else 2 if \"rRNA\" in chain_name else 4 ,\n          color                    =  'gray' if \"rRNA\" in chain_name else \"cyan\" if chain_name == \"eL39\" else 'pink' if chain_name=='uL23' else \"lightgreen\" if chain_name == \"uL4\" else \"gold\" if chain_name ==\"uL22\" else CHAIN_LANDMARK_COLORS[i],\n          opacity                  = 0.1 if chain_name not in [\"eL39\",\"uL4\",\"uL22\", 'uL23'] else 1 ,\n          render_points_as_spheres = True ,\n    )\n\nfor i, (label, color) in enumerate([( 'eL39','cyan' ),( 'uL4','lightgreen' ),( 'uL22','gold' )]):\n    offset   = i * 50  # Adjust the offset as needed\n    position = (20, 200 - offset, 0)\n    plotter.add_text( label, position=position, font_size=20, font=FONT,color=color, shadow=True )\n\nplotter.add_points( \n    # move_cords_to_normalized_cord_frame( grid_dimensions, mean_abs_vectors, np.array([ptc_midpoint]) ),\n    np.array([ptc_midpoint]),\n                    point_size=PTC_PT_SIZE, color=\"red\", render_points_as_spheres=True )\n\n#!--- Labels ----\nplotter.add_text('RCSB_ID:{}'.format(rcsb_id), position='upper_right', font_size=14, shadow=True, font=FONT, color='black')\n# plotter.add_text('eps: {} \\nmin_nbrs: {}'.format(eps, min_nbrs), position='upper_left', font_size=8, shadow=True, font=FONT, color='black')\nplotter.add_text('Tunnel Mesh Volume: {}'.format(round(mesh_.volume, 3)), position='lower_left', font_size=8, shadow=True, font=FONT, color='black')\nplotter.add_text('{}'.format(taxname), position='lower_right', font_size=8, shadow=True, font=FONT, color='black') \n\n\nplotter.show(auto_close=False)\n\n```\n\n::: {.cell-output .cell-output-display}\n```{=html}\n<script type=\"application/vnd.jupyter.widget-view+json\">\n{\"model_id\":\"fd9e5562c6e2439b8b2d19c9a720559d\",\"version_major\":2,\"version_minor\":0,\"quarto_mimetype\":\"application/vnd.jupyter.widget-view+json\"}\n</script>\n```\n:::\n:::\n\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js\" integrity=\"sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js\" integrity=\"sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==\" crossorigin=\"anonymous\" data-relocate-top=\"true\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n<script src=\"https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js\" crossorigin=\"anonymous\"></script>\n"
      ],
      "include-after-body": [
        "<script type=application/vnd.jupyter.widget-state+json>\n{\"state\":{\"1f392742f76d481bb9c68000a5f74f1b\":{\"model_module\":\"@jupyter-widgets/controls\",\"model_module_version\":\"2.0.0\",\"model_name\":\"HTMLStyleModel\",\"state\":{\"_model_module\":\"@jupyter-widgets/controls\",\"_model_module_version\":\"2.0.0\",\"_model_name\":\"HTMLStyleModel\",\"_view_count\":null,\"_view_module\":\"@jupyter-widgets/base\",\"_view_module_version\":\"2.0.0\",\"_view_name\":\"StyleView\",\"background\":null,\"description_width\":\"\",\"font_size\":null,\"text_color\":null}},\"2ea04278c0c343838d94bc9b17509689\":{\"model_module\":\"@jupyter-widgets/controls\",\"model_module_version\":\"2.0.0\",\"model_name\":\"HTMLStyleModel\",\"state\":{\"_model_module\":\"@jupyter-widgets/controls\",\"_model_module_version\":\"2.0.0\",\"_model_name\":\"HTMLStyleModel\",\"_view_count\":null,\"_view_module\":\"@jupyter-widgets/base\",\"_view_module_version\":\"2.0.0\",\"_view_name\":\"StyleView\",\"background\":null,\"description_width\":\"\",\"font_size\":null,\"text_color\":null}},\"321500e30ce64b2d8fd154595aada2b0\":{\"model_module\":\"@jupyter-widgets/base\",\"model_module_version\":\"2.0.0\",\"model_name\":\"LayoutModel\",\"state\":{\"_model_module\":\"@jupyter-widgets/base\",\"_model_module_version\":\"2.0.0\",\"_model_name\":\"LayoutModel\",\"_view_count\":null,\"_view_module\":\"@jupyter-widgets/base\",\"_view_module_version\":\"2.0.0\",\"_view_name\":\"LayoutView\",\"align_content\":null,\"align_items\":null,\"align_self\":null,\"border_bottom\":null,\"border_left\":null,\"border_right\":null,\"border_top\":null,\"bottom\":null,\"display\":null,\"flex\":null,\"flex_flow\":null,\"grid_area\":null,\"grid_auto_columns\":null,\"grid_auto_flow\":null,\"grid_auto_rows\":null,\"grid_column\":null,\"grid_gap\":null,\"grid_row\":null,\"grid_template_areas\":null,\"grid_template_columns\":null,\"grid_template_rows\":null,\"height\":null,\"justify_content\":null,\"justify_items\":null,\"left\":null,\"margin\":null,\"max_height\":null,\"max_width\":null,\"min_height\":null,\"min_width\":null,\"object_fit\":null,\"object_position\":null,\"order\":null,\"overflow\":null,\"padding\":null,\"right\":null,\"top\":null,\"visibility\":null,\"width\":null}},\"3e498eb038c94a069bae97f851a60d91\":{\"model_module\":\"@jupyter-widgets/controls\",\"model_module_version\":\"2.0.0\",\"model_name\":\"HTMLModel\",\"state\":{\"_dom_classes\":[],\"_model_module\":\"@jupyter-widgets/controls\",\"_model_module_version\":\"2.0.0\",\"_model_name\":\"HTMLModel\",\"_view_count\":null,\"_view_module\":\"@jupyter-widgets/controls\",\"_view_module_version\":\"2.0.0\",\"_view_name\":\"HTMLView\",\"description\":\"\",\"description_allow_html\":false,\"layout\":\"IPY_MODEL_5be5319721954b4e9520391820ff8acc\",\"placeholder\":\"​\",\"style\":\"IPY_MODEL_2ea04278c0c343838d94bc9b17509689\",\"tabbable\":null,\"tooltip\":null,\"value\":\"<iframe src=\\\"http://localhost:33623/index.html?ui=P_0x794113c32210_0&reconnect=auto\\\" class=\\\"pyvista\\\" style=\\\"width: 99%; height: 600px; border: 1px solid rgb(221,221,221);\\\"></iframe>\"}},\"432a4ee0aac34703a126b32b99817a0c\":{\"model_module\":\"@jupyter-widgets/controls\",\"model_module_version\":\"2.0.0\",\"model_name\":\"HTMLStyleModel\",\"state\":{\"_model_module\":\"@jupyter-widgets/controls\",\"_model_module_version\":\"2.0.0\",\"_model_name\":\"HTMLStyleModel\",\"_view_count\":null,\"_view_module\":\"@jupyter-widgets/base\",\"_view_module_version\":\"2.0.0\",\"_view_name\":\"StyleView\",\"background\":null,\"description_width\":\"\",\"font_size\":null,\"text_color\":null}},\"4cad17826cd545cdaa5eed6d12834257\":{\"model_module\":\"@jupyter-widgets/controls\",\"model_module_version\":\"2.0.0\",\"model_name\":\"HTMLModel\",\"state\":{\"_dom_classes\":[],\"_model_module\":\"@jupyter-widgets/controls\",\"_model_module_version\":\"2.0.0\",\"_model_name\":\"HTMLModel\",\"_view_count\":null,\"_view_module\":\"@jupyter-widgets/controls\",\"_view_module_version\":\"2.0.0\",\"_view_name\":\"HTMLView\",\"description\":\"\",\"description_allow_html\":false,\"layout\":\"IPY_MODEL_321500e30ce64b2d8fd154595aada2b0\",\"placeholder\":\"​\",\"style\":\"IPY_MODEL_432a4ee0aac34703a126b32b99817a0c\",\"tabbable\":null,\"tooltip\":null,\"value\":\"<iframe src=\\\"http://localhost:33623/index.html?ui=P_0x7941026608d0_1&reconnect=auto\\\" class=\\\"pyvista\\\" style=\\\"width: 99%; height: 600px; border: 1px solid rgb(221,221,221);\\\"></iframe>\"}},\"5be5319721954b4e9520391820ff8acc\":{\"model_module\":\"@jupyter-widgets/base\",\"model_module_version\":\"2.0.0\",\"model_name\":\"LayoutModel\",\"state\":{\"_model_module\":\"@jupyter-widgets/base\",\"_model_module_version\":\"2.0.0\",\"_model_name\":\"LayoutModel\",\"_view_count\":null,\"_view_module\":\"@jupyter-widgets/base\",\"_view_module_version\":\"2.0.0\",\"_view_name\":\"LayoutView\",\"align_content\":null,\"align_items\":null,\"align_self\":null,\"border_bottom\":null,\"border_left\":null,\"border_right\":null,\"border_top\":null,\"bottom\":null,\"display\":null,\"flex\":null,\"flex_flow\":null,\"grid_area\":null,\"grid_auto_columns\":null,\"grid_auto_flow\":null,\"grid_auto_rows\":null,\"grid_column\":null,\"grid_gap\":null,\"grid_row\":null,\"grid_template_areas\":null,\"grid_template_columns\":null,\"grid_template_rows\":null,\"height\":null,\"justify_content\":null,\"justify_items\":null,\"left\":null,\"margin\":null,\"max_height\":null,\"max_width\":null,\"min_height\":null,\"min_width\":null,\"object_fit\":null,\"object_position\":null,\"order\":null,\"overflow\":null,\"padding\":null,\"right\":null,\"top\":null,\"visibility\":null,\"width\":null}},\"8ee95d4a31574677930e7841eddd551e\":{\"model_module\":\"@jupyter-widgets/base\",\"model_module_version\":\"2.0.0\",\"model_name\":\"LayoutModel\",\"state\":{\"_model_module\":\"@jupyter-widgets/base\",\"_model_module_version\":\"2.0.0\",\"_model_name\":\"LayoutModel\",\"_view_count\":null,\"_view_module\":\"@jupyter-widgets/base\",\"_view_module_version\":\"2.0.0\",\"_view_name\":\"LayoutView\",\"align_content\":null,\"align_items\":null,\"align_self\":null,\"border_bottom\":null,\"border_left\":null,\"border_right\":null,\"border_top\":null,\"bottom\":null,\"display\":null,\"flex\":null,\"flex_flow\":null,\"grid_area\":null,\"grid_auto_columns\":null,\"grid_auto_flow\":null,\"grid_auto_rows\":null,\"grid_column\":null,\"grid_gap\":null,\"grid_row\":null,\"grid_template_areas\":null,\"grid_template_columns\":null,\"grid_template_rows\":null,\"height\":null,\"justify_content\":null,\"justify_items\":null,\"left\":null,\"margin\":null,\"max_height\":null,\"max_width\":null,\"min_height\":null,\"min_width\":null,\"object_fit\":null,\"object_position\":null,\"order\":null,\"overflow\":null,\"padding\":null,\"right\":null,\"top\":null,\"visibility\":null,\"width\":null}},\"fd9e5562c6e2439b8b2d19c9a720559d\":{\"model_module\":\"@jupyter-widgets/controls\",\"model_module_version\":\"2.0.0\",\"model_name\":\"HTMLModel\",\"state\":{\"_dom_classes\":[],\"_model_module\":\"@jupyter-widgets/controls\",\"_model_module_version\":\"2.0.0\",\"_model_name\":\"HTMLModel\",\"_view_count\":null,\"_view_module\":\"@jupyter-widgets/controls\",\"_view_module_version\":\"2.0.0\",\"_view_name\":\"HTMLView\",\"description\":\"\",\"description_allow_html\":false,\"layout\":\"IPY_MODEL_8ee95d4a31574677930e7841eddd551e\",\"placeholder\":\"​\",\"style\":\"IPY_MODEL_1f392742f76d481bb9c68000a5f74f1b\",\"tabbable\":null,\"tooltip\":null,\"value\":\"<iframe src=\\\"http://localhost:33623/index.html?ui=P_0x79410226bf50_2&reconnect=auto\\\" class=\\\"pyvista\\\" style=\\\"width: 99%; height: 600px; border: 1px solid rgb(221,221,221);\\\"></iframe>\"}}},\"version_major\":2,\"version_minor\":0}\n</script>\n"
      ]
    }
  }
}